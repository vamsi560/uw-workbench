import json
import logging
from typ    def _create_extraction_prompt(self, text: str) -> str:
        """Create comprehensive extraction prompt for insurance submission data"""
        return f"""
You are an expert insurance data extraction specialist with deep knowledge of commercial cyber liability insurance submissions. Extract all available information from the provided content and structure it according to the specified field schema with high accuracy and completeness.

**Content to Process:**
{text}

**Instructions:**
1. Read through all provided content carefully
2. Extract data for each field in the schema below
3. Return structured JSON with all identified fields
4. Mark unavailable fields as null
5. Apply proper data formatting (dates as YYYY-MM-DD, numbers without currency symbols)
6. Convert Yes/No responses to boolean values
7. Handle abbreviated amounts (5M = 5000000, 2.5K = 2500)

**Extract the following fields and return ONLY a valid JSON object:**
{{
    "agency_name": "Name of the insurance agency",
    "agency_code": "Agency identification code", 
    "broker_name": "Individual broker/agent name",
    "broker_email": "Broker's email address",
    "broker_phone": "Broker's phone number",
    "submission_id": "Unique submission reference number",
    "submission_date": "Date submission was received (YYYY-MM-DD)",
    "insured_name": "Legal name of the insured company",
    "legal_structure": "Corporation, LLC, Partnership, etc.",
    "parent_company": "Parent company name if applicable",
    "subsidiaries": "List of subsidiary companies as array",
    "address_1": "Primary street address",
    "address_2": "Secondary address line (suite, unit, etc.)",
    "city": "City name",
    "state": "State abbreviation or full name", 
    "zip_code": "ZIP or postal code",
    "address_type": "Business, Mailing, etc.",
    "country": "Country name",
    "base_state": "Base state for insurance purposes",
    "organization": "Type of organization",
    "industry_code": "Industry classification code",
    "description_of_business": "Detailed business description",
    "fein": "Federal Employer Identification Number",
    "preferred_language": "Preferred communication language",
    "term_type": "Annual, Multi-year, etc.",
    "effective_date": "Policy effective date (YYYY-MM-DD)",
    "expiration_date": "Policy expiration date (YYYY-MM-DD)",
    "written_date": "Date application was written (YYYY-MM-DD)",
    "producer_code": "Producer identification code",
    "description_of_operations": "Specific operational details",
    "policy_type": "Type of policy (Cyber Liability, etc.)",
    "coverage_form": "Specific coverage form used",
    "request_retroactive_coverage": "Whether retroactive coverage is requested (boolean)",
    "requested_retroactive_date": "Requested retroactive date (YYYY-MM-DD)",
    "naics_code": "North American Industry Classification System code",
    "operations": "Key business operations",
    "state_of_incorporation": "State where company is incorporated",
    "total_full_time_employees": "Count of full-time employees (number)",
    "total_part_time_employees": "Count of part-time employees (number)",
    "total_payroll": "Annual payroll in dollars (number)",
    "total_revenues": "Annual revenues in dollars (number)",
    "total_assets": "Total company assets in dollars (number)",
    "total_liabilities": "Total company liabilities in dollars (number)",
    "separate_defense_costs_limit": "Separate defense costs limit (boolean)",
    "does_insured_conduct_online_transactions": "Online transaction activity (boolean)",
    "remote_access_granted_to_third_parties": "Third-party remote access (boolean)",
    "does_insured_have_websites": "Company website presence (boolean)",
    "website_addresses": "List of company website URLs as array",
    "active_social_media_profiles": "Active social media presence (boolean)",
    "network_security_contact": "Name of network security contact",
    "is_contact_employed_by_applicant": "Whether security contact is employee (boolean)",
    "commercial_cyber_liability": "Commercial cyber liability coverage (boolean)",
    "policy_liability": "Type of liability coverage",
    "policy_aggregate_limit": "Policy aggregate limit in dollars (number)",
    "retention": "Policy retention/deductible in dollars (number)",
    "extortion_threat_ransom_payments_sublimit": "Ransom payment sublimit in dollars (number)",
    "business_income_extra_expense_sublimit": "Business income sublimit in dollars (number)",
    "waiting_period_hours": "Waiting period in hours (number)",
    "public_relations_expense_sublimit": "PR expense sublimit in dollars (number)",
    "include_computer_funds_transfer_fraud": "Computer fraud coverage inclusion (boolean)",t, Any, Optional
import google.generativeai as genai

from config import settings

logger = logging.getLogger(__name__)


class LLMService:
    """Service for interacting with Google Gemini LLM"""
    
    def __init__(self):
        self.google_client = None
        
        # Initialize Google Gemini client with configured model
        if settings.gemini_api_key:
            genai.configure(api_key=settings.gemini_api_key)
            self.google_client = genai.GenerativeModel(settings.gemini_model)
    
    def extract_insurance_data(self, combined_text: str) -> Dict[str, Any]:
        """Extract structured insurance data from text using Google Gemini"""
        
        prompt = self._create_extraction_prompt(combined_text)
        
        try:
            if self.google_client:
                return self._extract_with_google(prompt)
            else:
                raise Exception("Google Gemini not configured")
                
        except Exception as e:
            logger.error(f"Error extracting data with Gemini: {str(e)}")
            # Return default structure if LLM fails
            return self._get_default_response()
    
    def _create_extraction_prompt(self, text: str) -> str:
        """Create the prompt for data extraction with comprehensive insurance fields"""
        return f"""You are an expert cyber insurance underwriter analyzing an insurance submission.
Extract the following information from the text and return ONLY a valid JSON object.

Text to analyze:
{text}

Extract these fields for comprehensive cyber insurance submission:
{{
    "agency_id": "Insurance agency or broker identifier",
    "agency_name": "Insurance agency or broker name", 
    "agency_contact": "Agency contact person",
    "agency_email": "Agency contact email",
    "agency_phone": "Agency contact phone",
    "producer_name": "Producer or agent name",
    "producer_code": "Producer code or ID",
    "broker_name": "Insurance broker name (if different from agency)",
    "broker_contact": "Broker contact person",
    "broker_email": "Broker contact email", 
    "broker_phone": "Broker contact phone",
    "company_name": "Name of the company requesting insurance",
    "named_insured": "Full legal name of the named insured",
    "dba_name": "Doing Business As name (if applicable)",
    "company_ein": "Company EIN/Tax ID number",
    "company_duns": "Company DUNS number",
    "company_naic": "NAIC code",
    "entity_type": "Entity type (Corporation, LLC, Partnership, etc.)",
    "insured_name": "Primary contact name or insured party name",
    "contact_name": "Primary contact person's name",
    "contact_title": "Primary contact's job title",
    "contact_email": "Primary contact email address",
    "contact_phone": "Primary contact phone number",
    "mailing_address": "Mailing address (street, city, state, zip)",
    "mailing_city": "Mailing address city",
    "mailing_state": "Mailing address state", 
    "mailing_zip": "Mailing address ZIP code",
    "business_address": "Business address (street, city, state, zip)",
    "business_city": "Business address city",
    "business_state": "Business address state",
    "business_zip": "Business address ZIP code",
    "industry": "Industry sector (healthcare, technology, financial_services, etc.)",
    "industry_code": "SIC or NAICS industry code",
    "business_description": "Description of business operations",
    "company_size": "Company size (small, medium, large, enterprise)",
    "employee_count": "Number of employees", 
    "annual_revenue": "Annual revenue amount",
    "years_in_business": "Years the company has been in operation",
    "current_policy_number": "Current policy number (if renewal)",
    "current_carrier": "Current insurance carrier",
    "current_expiration": "Current policy expiration date",
    "renewal_indicator": "Is this a renewal (yes/no)",
    "policy_type": "Type of cyber insurance policy",
    "coverage_amount": "Requested coverage amount/limit",
    "aggregate_limit": "Aggregate coverage limit",
    "per_occurrence_limit": "Per occurrence limit",
    "deductible": "Policy deductible amount",
    "self_insured_retention": "Self-insured retention amount",
    "effective_date": "Requested policy effective date",
    "expiry_date": "Requested policy expiry date",
    "policy_term": "Policy term (6 months, 1 year, etc.)",
    "privacy_liability_limit": "Privacy liability coverage limit",
    "network_security_limit": "Network security coverage limit",
    "data_breach_response_limit": "Data breach response coverage limit",
    "business_interruption_limit": "Business interruption coverage limit", 
    "cyber_extortion_limit": "Cyber extortion coverage limit",
    "regulatory_fines_limit": "Regulatory fines coverage limit",
    "forensic_costs_limit": "Forensic costs coverage limit",
    "notification_costs_limit": "Notification costs coverage limit",
    "credit_monitoring_limit": "Credit monitoring coverage limit",
    "crisis_management_limit": "Crisis management coverage limit",
    "data_types": "Types of data handled (PII, PHI, payment data, etc.)",
    "records_count": "Number of records/data subjects",
    "pci_compliance": "PCI DSS compliance status",
    "hipaa_compliance": "HIPAA compliance status (if applicable)",
    "sox_compliance": "SOX compliance status (if applicable)",
    "gdpr_compliance": "GDPR compliance status (if applicable)",
    "ccpa_compliance": "CCPA compliance status (if applicable)",
    "iso27001_certified": "ISO 27001 certification status",
    "soc2_certified": "SOC 2 certification status",
    "other_certifications": "Other security certifications",
    "security_measures": "Security measures and controls in place",
    "incident_response_plan": "Incident response plan status",
    "business_continuity_plan": "Business continuity plan status",
    "disaster_recovery_plan": "Disaster recovery plan status",
    "employee_training": "Security awareness training program",
    "penetration_testing": "Penetration testing frequency",
    "vulnerability_scanning": "Vulnerability scanning program",
    "multi_factor_auth": "Multi-factor authentication implementation",
    "encryption_at_rest": "Data encryption at rest",
    "encryption_in_transit": "Data encryption in transit",
    "endpoint_protection": "Endpoint protection solution",
    "email_security": "Email security measures",
    "network_monitoring": "Network monitoring and logging",
    "access_controls": "Access control measures",
    "patch_management": "Patch management process",
    "cloud_services": "Cloud services usage",
    "cloud_providers": "Cloud service providers used",
    "remote_workforce_pct": "Percentage of remote workforce",
    "third_party_vendors": "Third party vendor relationships",
    "vendor_risk_management": "Vendor risk management program",
    "previous_breach": "Previous security incidents or breaches",
    "breach_details": "Details of previous breaches",
    "breach_costs": "Costs associated with previous breaches",
    "litigation_history": "Cyber-related litigation history", 
    "regulatory_actions": "Previous regulatory actions",
    "website_url": "Company website URL",
    "annual_website_revenue": "Annual revenue from website/e-commerce",
    "mobile_apps": "Mobile applications operated",
    "api_endpoints": "Number of API endpoints",
    "databases": "Number and types of databases",
    "payment_processing": "Payment processing systems",
    "underwriter_name": "Assigned underwriter name",
    "underwriter_email": "Underwriter contact email",
    "submission_date": "Date of submission",
    "quote_deadline": "Quote deadline date",
    "bind_date": "Target bind date",
    "special_terms": "Special terms or conditions requested",
    "exclusions": "Requested exclusions", 
    "additional_coverages": "Additional coverages requested",
    "remarks": "Additional remarks or notes"
}}

CRITICAL INSTRUCTIONS:
- Extract all available information, mark "Not specified" if information is not found
- For amounts: Convert to full numeric values (e.g., "$5 million" → "5000000")
- For dates: Use YYYY-MM-DD format when possible
- For percentages: Extract as numbers (e.g., "25%" → "25")
- For yes/no fields: Use lowercase "yes" or "no"
- Return ONLY the JSON object, no additional text
- Ensure all field names match exactly as specified above
"""
    
    def _extract_with_google(self, prompt: str) -> Dict[str, Any]:
        """Extract data using Google Gemini"""
        try:
            # Configure generation parameters
            generation_config = genai.types.GenerationConfig(
                max_output_tokens=settings.max_tokens,
                temperature=0.1,
            )
            
            response = self.google_client.generate_content(
                prompt, 
                generation_config=generation_config
            )
            content = response.text.strip()
            logger.info(f"Google Gemini response: {content}")
            return self._parse_json_response(content)
            
        except Exception as e:
            logger.error(f"Error with Google Gemini: {str(e)}")
            raise
    
    def _parse_json_response(self, content: str) -> Dict[str, Any]:
        """Parse JSON response from LLM"""
        try:
            # Clean up response - remove any markdown formatting
            content = content.replace("```json", "").replace("```", "").strip()
            
            # Parse JSON
            data = json.loads(content)
            
            # Validate required fields for cyber insurance
            required_fields = ["company_name", "insured_name", "contact_email", "industry", "coverage_amount", "policy_type", "effective_date"]
            for field in required_fields:
                if field not in data:
                    data[field] = "Not specified"
                elif not isinstance(data[field], str):
                    data[field] = str(data[field])
            
            logger.info(f"Successfully parsed JSON response: {data}")
            return data
            
        except json.JSONDecodeError as e:
            logger.error(f"Error parsing JSON response: {str(e)}")
            logger.error(f"Raw content: {content}")
            return self._get_default_response()
        except Exception as e:
            logger.error(f"Error processing response: {str(e)}")
            return self._get_default_response()
    
    def _get_default_response(self) -> Dict[str, Any]:
        """Return default response when LLM fails"""
        return {
            "company_name": "Not specified",
            "insured_name": "Not specified",
            "contact_email": "Not specified",
            "contact_name": "Not specified",
            "industry": "Not specified",
            "company_size": "Not specified",
            "coverage_amount": "Not specified",
            "policy_type": "cyber",
            "effective_date": "Not specified",
            "expiry_date": "Not specified",
            "data_types": "Not specified",
            "security_measures": "Not specified",
            "compliance_certifications": "Not specified",
            "previous_incidents": "Not specified",
            "business_type": "Not specified"
        }

    def summarize_submission(self, subject: Optional[str], body_text: Optional[str], extracted_fields: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Create a concise underwriting-oriented summary for a submission.

        Returns a dict with keys: summary, key_points, risk_flags.
        """
        try:
            extracted_json = json.dumps(extracted_fields or {}, ensure_ascii=False)
            subject_text = subject or ""
            body = body_text or ""
            prompt = f"""
You are an expert cyber insurance underwriter. Summarize the submission succinctly for triage.

Subject: {subject_text}

Extracted Fields JSON:
{extracted_json}

Email/Notes:
{body}

Return ONLY valid JSON with the following structure:
{{
  "summary": "1-2 sentences overall context",
  "key_points": ["3-6 short bullets with concrete facts"],
  "risk_flags": ["0-5 bullets highlighting potential underwriting risks if any"]
}}
"""

            if not self.google_client:
                key_points = []
                if extracted_fields:
                    for k in [
                        "company_name", "industry", "coverage_amount", "policy_type", "effective_date"
                    ]:
                        v = extracted_fields.get(k)
                        if v and isinstance(v, str) and v != "Not specified":
                            key_points.append(f"{k.replace('_',' ').title()}: {v}")
                summary = subject_text or "Submission summary not available"
                risk_flags = []
                return {"summary": summary, "key_points": key_points[:6], "risk_flags": risk_flags}

            generation_config = genai.types.GenerationConfig(
                max_output_tokens=min(getattr(settings, "max_tokens", 512), 768),
                temperature=0.2,
            )
            response = self.google_client.generate_content(prompt, generation_config=generation_config)
            content = (response.text or "").strip()
            content = content.replace("```json", "").replace("```", "").strip()
            data = json.loads(content)

            if not isinstance(data, dict):
                raise ValueError("LLM summarize response not a JSON object")
            for key in ["summary", "key_points", "risk_flags"]:
                if key not in data:
                    data[key] = [] if key != "summary" else ""
            if not isinstance(data.get("key_points"), list):
                data["key_points"] = [str(data.get("key_points"))]
            if not isinstance(data.get("risk_flags"), list):
                data["risk_flags"] = [str(data.get("risk_flags"))]
            data["summary"] = str(data.get("summary", ""))
            return data
        except Exception as e:
            logger.error("Error generating submission summary", exc_info=e)
            return {
                "summary": subject or "Submission",
                "key_points": [],
                "risk_flags": []
            }


# Global instance
llm_service = LLMService()
